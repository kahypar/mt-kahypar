#include "evo_partitioner.h"
#include "mt-kahypar/partition/partitioner.h"
#include "mt-kahypar/partition/multilevel.h"
#include "mt-kahypar/partition/recursive_bipartitioning.h"
#include "mt-kahypar/partition/deep_multilevel.h"
#include "mt-kahypar/partition/preprocessing/sparsification/degree_zero_hn_remover.h"
#include "mt-kahypar/partition/preprocessing/sparsification/large_he_remover.h"
#include "mt-kahypar/io/partitioning_output.h"
#ifdef KAHYPAR_ENABLE_STEINER_TREE_METRIC
#include "mt-kahypar/partition/mapping/initial_mapping.h"
#endif

#include "mt-kahypar/io/hypergraph_io.h"
#include <fstream>
#include <string>
#include <tbb/task_arena.h>
#include <csignal>

namespace mt_kahypar {

    template<typename TypeTraits>
    typename EvoPartitioner<TypeTraits>::PartitionedHypergraph EvoPartitioner<TypeTraits>::partition(
        Hypergraph& hypergraph, Context& context, TargetGraph* target_graph) {

        EvoPartitioner<TypeTraits>::configurePreprocessing(hypergraph, context);
        EvoPartitioner<TypeTraits>::setupContext(hypergraph, context, target_graph);

        io::printContext(context);
        io::printMemoryPoolConsumption(context);
        io::printInputInformation(context, hypergraph);

        #ifdef KAHYPAR_ENABLE_STEINER_TREE_METRIC
        bool map_partition_to_target_graph_at_the_end = false;
        if ( context.partition.objective == Objective::steiner_tree &&
            context.mapping.use_two_phase_approach ) {
        map_partition_to_target_graph_at_the_end = true;
        context.partition.objective = Objective::km1;
        context.setupGainPolicy();
        }
        #endif

        // init global timers for benchmark mode
        {
        std::lock_guard<std::mutex> lock(best_tracking_mutex_);
        global_best_fitness_ = std::numeric_limits<HyperedgeWeight>::max();
        global_best_time_ = std::chrono::milliseconds(0);
        }

        // DISABLED -- Individuals have incorrect indexing after preprocessing
        // ################## PREPROCESSING ##################
        utils::Timer& timer = utils::Utilities::instance().getTimer(context.utility_id);
        timer.start_timer("preprocessing", "Preprocessing");
        // DegreeZeroHypernodeRemover<TypeTraits> degree_zero_hn_remover(context);
        // LargeHyperedgeRemover<TypeTraits> large_he_remover(context);
        // Partitioner<TypeTraits>::preprocess(hypergraph, context, target_graph);
        // EvoPartitioner<TypeTraits>::sanitize(hypergraph, context, degree_zero_hn_remover, large_he_remover);
        timer.stop_timer("preprocessing");

        // ################## EVOLUTIONARY PARTITIONING ##################
        //LOG << "DEBUG: Calling generateInitialPopulation...";
        // The initial population is generated by calling the standard partitioner repeatedly.
        Population population;
        std::string history = generateInitialPopulation(hypergraph, context, target_graph, population);
        //LOG << "DEBUG: generateInitialPopulation finished.";

        //LOG << "DEBUG: Calling performEvolution...";
        history += performEvolution(hypergraph, context, target_graph, population);
        //LOG << "DEBUG: performEvolution finished.";

        if (context.evolutionary.history_file != "" && context.partition.enable_benchmark_mode) {
            std::ofstream out_stream(context.evolutionary.history_file.c_str(), 
                                   std::ios::out | std::ios::trunc); 
            out_stream << history;
            out_stream.close();
        }
        if (context.evolutionary.diff_matrix_file != "" && context.partition.enable_benchmark_mode) {
            std::ofstream out_stream(context.evolutionary.diff_matrix_file.c_str(),
                                   std::ios::out | std::ios::trunc);
            out_stream << diff_matrix_history;
            out_stream.close();
        }


        // ################## FINALIZATION ##################
        // After evolution, we take the best individual and create the final partition.
        PartitionedHypergraph final_partition(context.partition.k, const_cast<Hypergraph&>(hypergraph));
        
        size_t best_idx = population.bestSafe();
        std::vector<PartitionID> best_partition_vec = population.individualAtSafe(best_idx).partition();
        final_partition.doParallelForAllNodes([&](const HypernodeID& hn) {
            final_partition.setOnlyNodePart(hn, best_partition_vec[hn]);
        });
        final_partition.initializePartition();

        ASSERT([&] {
            bool success = true;
            if ( final_partition.hasFixedVertices() ) {
                for ( const HypernodeID& hn : final_partition.nodes() ) {
                    if ( final_partition.isFixed(hn) &&
                        final_partition.fixedVertexBlock(hn) != final_partition.partID(hn) ) {
                        LOG << "Node" << hn << "is fixed to block" << final_partition.fixedVertexBlock(hn)
                            << ", but is assigned to block" << final_partition.partID(hn);
                        success = false;
                    }
                }
            }
            return success;
        }(), "Some fixed vertices are not assigned to their corresponding block");

        // ################## POSTPROCESSING ##################
        timer.start_timer("postprocessing", "Postprocessing");
        // large_he_remover.restoreLargeHyperedges(final_partition);
        // degree_zero_hn_remover.restoreDegreeZeroHypernodes(final_partition);
        // forceFixedVertexAssignment(partitioned_hypergraph, context);
        timer.stop_timer("postprocessing");

        #ifdef KAHYPAR_ENABLE_STEINER_TREE_METRIC
            if ( map_partition_to_target_graph_at_the_end ) {
            ASSERT(target_graph);
            context.partition.objective = Objective::steiner_tree;
            timer.start_timer("one_to_one_mapping", "One-To-One Mapping");
            InitialMapping<TypeTraits>::mapToTargetGraph(
                 final_partition, *target_graph, context);
            timer.stop_timer("one_to_one_mapping");
            }
        #endif

        if (context.partition.verbose_output) {
            io::printHypergraphInfo(final_partition.hypergraph(), context,
                                    "Uncoarsened Hypergraph", context.partition.show_memory_consumption);
            io::printStripe();
        }

        return final_partition;
    }


    template<typename TypeTraits>
    std::string EvoPartitioner<TypeTraits>::generateInitialPopulation(const Hypergraph& hg, Context& context, TargetGraph* target_graph, Population& population) {
        context.partition.verbose_output = false;
        utils::Timer& timer = utils::Utilities::instance().getTimer(context.utility_id);
        auto start = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch());
        auto now = start;
        auto time_elapsed = now - start;
        auto duration = std::chrono::seconds(context.partition.time_limit);
        std::string history = "Starttime: " + std::to_string(start.count()) + "\n";
        
        // INITIAL POPULATION
        if (context.evolutionary.dynamic_population_size) {
            HighResClockTimepoint start = std::chrono::high_resolution_clock::now();
            timer.start_timer("evolutionary", "Evolutionary");
            auto fitness = generateIndividual(hg, context, target_graph, population).fitness();
            now = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch());

            // best result tracking for benchmark
            if (context.partition.enable_benchmark_mode) {
                std::string improvement = checkAndLogNewBest(fitness, "Initial", now);
                if (!improvement.empty()) {
                    history += improvement;
                    // std::lock_guard<std::mutex> lock(diff_matrix_history_mutex);
                    // std::string diff_matrix = population.updateDiffMatrix();
                    // LOG << "DEBUG: Initial population diff matrix:\n" << diff_matrix;
                    // diff_matrix_history += diff_matrix;
                }
            }

            timer.stop_timer("evolutionary");

            ++context.evolutionary.iteration;
            int dynamic_population_size = std::round(context.evolutionary.dynamic_population_amount_of_time
                                                    * context.partition.time_limit
                                                    / timer.get("evolutionary"));
            int minimal_size = std::max(dynamic_population_size, 3);

            context.evolutionary.population_size = std::min(minimal_size, 50);
            LOG << context.evolutionary.population_size;
            //LOG << population;
        }
        LOG << "DEBUG: Initial population target size =" << context.evolutionary.population_size;
        int best = std::numeric_limits<HyperedgeWeight>::max();
        int iteration = 0;

        while (population.size() < context.evolutionary.population_size &&
            time_elapsed <= duration) {
            //LOG << "DEBUG: Initial pop loop - Iteration" << iteration << ", Pop size:" << population.size();
            ++context.evolutionary.iteration;
            timer.start_timer("evolutionary", "Evolutionary");
           
            auto cur = generateIndividual(hg, context, target_graph, population).fitness();
            timer.stop_timer("evolutionary");
            //LOG << "DEBUG: Generated one individual with fitness" << cur;
            now = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch());
            
            if (context.partition.enable_benchmark_mode) {
                std::string improvement = checkAndLogNewBest(cur, "Initial", now);
                if (!improvement.empty()) {
                    history += improvement;
                }
            }
            
            // if (iteration == 0 || (cur < best)) {
            //     best = cur;
            //     history += "" + std::to_string(now.count()) + ", Repetition, " + std::to_string(cur) + "\n";
            // }
            iteration++;
            time_elapsed = now - start;
        }
        context.evolutionary.time_elapsed = time_elapsed;
        context.partition.verbose_output = true;
        return history;
    }

    template<typename TypeTraits>
    const Individual & EvoPartitioner<TypeTraits>::generateIndividual(const Hypergraph& input_hg, Context& context, TargetGraph* target_graph, Population& population) {
        Hypergraph hypergraph_copy = input_hg.copy(parallel_tag_t{});

        //LOG << "DEBUG: generateIndividual: Calling standard partitioner...";

        Context ip_context(context);

        // If we are not using individual part weights, ensure max_part_weights is empty
        if (!ip_context.partition.use_individual_part_weights) {
                ip_context.partition.max_part_weights.clear();
        }

        EvoPartitioner<TypeTraits>::PartitionedHypergraph partitioned_hypergraph;
        // PartitionedHypergraph partitioned_hypergraph =
        //     Partitioner<TypeTraits>::partition(hypergraph_copy, ip_context, target_graph);
        if (context.partition.mode == Mode::direct) {
            partitioned_hypergraph = Multilevel<TypeTraits>::partition(hypergraph_copy, context, target_graph);
        } else if (context.partition.mode == Mode::recursive_bipartitioning) {
            partitioned_hypergraph = RecursiveBipartitioning<TypeTraits>::partition(hypergraph_copy, context, target_graph);
        } else if (context.partition.mode == Mode::deep_multilevel) {
            partitioned_hypergraph = DeepMultilevel<TypeTraits>::partition(hypergraph_copy, context);
        } else {
            throw InvalidParameterException("Invalid partitioning mode!");
        }
        //LOG << "DEBUG: generateIndividual: Partitioner finished.";

        // LOG << "DEBUG: Partitioned hg node count: " << partitioned_hypergraph.nodes().size();
        // LOG << "DEBUG: Partitioned hg initial node count: " << partitioned_hypergraph.initialNumNodes();
        // LOG << "DEBUG: Input hg node count: " << input_hg.nodes().size();
        Individual individual(partitioned_hypergraph, context);
        return population.addStartingIndividual(individual, context);
    } 

    template<typename TypeTraits>
    EvoDecision EvoPartitioner<TypeTraits>::decideNextMove(const Context& context) {
        if (utils::Randomize::instance().getRandomFloat(0, 1, THREAD_ID) < context.evolutionary.mutation_chance) {
            return EvoDecision::mutation;
        }
        return EvoDecision::combine;
    }

    template<typename TypeTraits>
    EvoMutateStrategy EvoPartitioner<TypeTraits>::decideNextMutation(const Context& context) {
        if (utils::Randomize::instance().flipCoin(THREAD_ID)) {
            return EvoMutateStrategy::vcycle;
        }
        return EvoMutateStrategy::new_initial_partitioning_vcycle;
    }


    template<typename TypeTraits>
    vec<PartitionID> EvoPartitioner<TypeTraits>::combinePartitions(const Context& context, Population& population, const std::vector<size_t>& ids) {
        // aquire lock --- possibly unnecessary
        std::vector<std::vector<PartitionID>> parent_partitions;
        for (auto id : ids) {
            parent_partitions.push_back(population.partitionCopySafe(id)); // FIXED
        }

        vec<PartitionID> combined(parent_partitions[0].size());
        std::unordered_map<std::string, int> tuple_to_block;
        int current_community = 0;

        for (int vertex = 0; vertex < combined.size(); vertex++) {
            std::string partition_tuple;
            for (size_t i = 0; i < parent_partitions.size(); ++i) {
                partition_tuple += std::to_string(parent_partitions[i][vertex]) + ",";
            }

            if (tuple_to_block.find(partition_tuple) == tuple_to_block.end()) {
                tuple_to_block[partition_tuple] = current_community++;
            }

            combined[vertex] = tuple_to_block[partition_tuple];
        }

        return combined;
    }

    template<typename TypeTraits>
    std::string EvoPartitioner<TypeTraits>::performCombine(const Hypergraph& input_hg, const Context& context, TargetGraph* target_graph, Population& population) {
        std::vector<size_t> parents;
        size_t best = population.randomIndividualSafe(); // FIXED
        parents.push_back(best);
        for (int x = 1; x < context.evolutionary.kway_combine; x++) {
            size_t new_parent = population.randomIndividualSafe(); // FIXED
            parents.push_back(new_parent);
            if (population.fitnessAtSafe(new_parent) <= population.fitnessAtSafe(best)) { // FIXED
                best = new_parent;
            }
        }
        
        std::vector<PartitionID> best_partition = population.partitionCopySafe(best);
        
        std::unordered_map<PartitionID, int> comm_to_block;
        vec<PartitionID> comms = combinePartitions(context, population, parents);

        Hypergraph hypergraph = input_hg.copy(parallel_tag_t{});
        PartitionedHypergraph partitioned_hypergraph(context.partition.k, hypergraph);  

        for (const HypernodeID& hn : hypergraph.nodes()) {
            partitioned_hypergraph.setOnlyNodePart(hn, best_partition[hn]);
            if (comm_to_block.find(comms[hn]) == comm_to_block.end()) {
                comm_to_block[comms[hn]] = best_partition[hn];
            }
        }

        partitioned_hypergraph.initializePartition();
        hypergraph.setCommunityIDs(std::move(comms));
        if (context.partition.mode == Mode::direct) {
            //V-cycle requires a context with initialized part weights
            Context vc_context(context);
            vc_context.setupPartWeights(hypergraph.totalWeight());
            Multilevel<TypeTraits>::evolutionPartitionVCycle(hypergraph, partitioned_hypergraph, vc_context, comm_to_block, target_graph);
        } else {
            throw InvalidParameterException("Invalid partitioning mode!");
        }

        Individual individual(partitioned_hypergraph, context);
        
        std::string ret = "";
        if (context.partition.enable_benchmark_mode) {
            auto time = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch());
            ret = checkAndLogNewBest(individual.fitness(), "Combine", time);
        }
        population.insert(std::move(individual), context);
        if (context.partition.enable_benchmark_mode && !ret.empty()) {
            std::lock_guard<std::mutex> lock(diff_matrix_history_mutex);
            std::string diff_matrix = population.updateDiffMatrix();
            diff_matrix_history += diff_matrix;
        }
        return ret;
    }

    template<typename TypeTraits>
    std::string EvoPartitioner<TypeTraits>::performMutation(const Hypergraph& input_hg, const Context& context, TargetGraph* target_graph, Population& population) {
        Hypergraph hypergraph = input_hg.copy(parallel_tag_t{});
        const size_t mutation_position = population.randomIndividualSafe(); // FIXED
        std::vector<PartitionID> cur = population.individualAtSafe(mutation_position).partition(); // FIXED
        PartitionedHypergraph partitioned_hypergraph(context.partition.k, hypergraph);
        EvoMutateStrategy mutation = decideNextMutation(context);
        if (mutation == EvoMutateStrategy::vcycle) {
            //LOG << "Mutating old: ";
            vec<PartitionID> comms(hypergraph.initialNumNodes());
            std::unordered_map<PartitionID, int> comm_to_block;
            for ( const HypernodeID& hn : hypergraph.nodes() ) {
                partitioned_hypergraph.setOnlyNodePart(hn, cur[hn]);
                comms[hn] = cur[hn];
            }
            for (PartitionID i = 0; i < context.partition.k; i++) {
                comm_to_block[i] = i;
            }
            partitioned_hypergraph.initializePartition();
            hypergraph.setCommunityIDs(std::move(comms));
            if (context.partition.mode == Mode::direct) {
                // Ensure part weights are initialized for metrics inside the V-cycle
                Context vc_context(context);
                vc_context.setupPartWeights(hypergraph.totalWeight());
                Multilevel<TypeTraits>::evolutionPartitionVCycle(hypergraph, partitioned_hypergraph, vc_context, comm_to_block, target_graph);
            } else {
                throw InvalidParameterException("Invalid partitioning mode!");
            }
        } else if (mutation == EvoMutateStrategy::new_initial_partitioning_vcycle) {
            //LOG << "Mutating new: ";
            vec<PartitionID> comms(hypergraph.initialNumNodes());
            for ( const HypernodeID& hn : hypergraph.nodes() ) {
                comms[hn] = cur[hn];
            }
            hypergraph.setCommunityIDs(std::move(comms));
            // Create a mutable context copy for a fresh standard partitioning run.
            Context mut_context(context);
            if (!mut_context.partition.use_individual_part_weights) {
                mut_context.partition.max_part_weights.clear();
            }
            partitioned_hypergraph = Partitioner<TypeTraits>::partition(hypergraph, mut_context, target_graph);
        }
        Individual individual(partitioned_hypergraph, context);

        std::string ret = "";
        if (context.partition.enable_benchmark_mode) {
            auto time = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch());
            std::string operation_type = (mutation == EvoMutateStrategy::vcycle) ? "MutateOld" : "MutateNew";
            ret = checkAndLogNewBest(individual.fitness(), operation_type, time);
        }

        // std::string ret = "";
        // if (individual.fitness() < population.bestFitnessSafe()) { // FIXED
        //     auto time = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch());
        //     if (mutation == EvoMutateStrategy::vcycle) {
        //         ret = "" + std::to_string(time.count()) + ", MutateOld, " + std::to_string(individual.fitness()) + "\n";
        //     } else {
        //         ret = "" + std::to_string(time.count()) + ", MutateNew, " + std::to_string(individual.fitness()) + "\n";
        //     }
        // }
        population.insert(std::move(individual), context);
        if (context.partition.enable_benchmark_mode && !ret.empty()) {;
            std::lock_guard<std::mutex> lock(diff_matrix_history_mutex);
            std::string diff_matrix = population.updateDiffMatrix();
            diff_matrix_history += diff_matrix;
        }

        return ret;
    }

    inline void disableTimerAndStatsEvo(const Context& context) {
        if ( context.type == ContextType::main && context.partition.mode == Mode::direct ) {
            utils::Utilities& utils = utils::Utilities::instance();
            parallel::MemoryPool::instance().deactivate_unused_memory_allocations();
            utils.getTimer(context.utility_id).disable();
            utils.getStats(context.utility_id).disable();
        }
    }

    inline void enableTimerAndStatsEvo(const Context& context) {
        if ( context.type == ContextType::main && context.partition.mode == Mode::direct ) {
            utils::Utilities& utils = utils::Utilities::instance();
            parallel::MemoryPool::instance().activate_unused_memory_allocations();
            utils.getTimer(context.utility_id).enable();
            utils.getStats(context.utility_id).enable();
        }
    }

    template<typename TypeTraits>
    std::string EvoPartitioner<TypeTraits>::performEvolution(const Hypergraph& hg, Context& context, TargetGraph* target_graph, Population& population) {
        context.partition.verbose_output = false;
        int timelimit = context.partition.time_limit;
        utils::Timer& timer = utils::Utilities::instance().getTimer(context.utility_id);
        auto time_start = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch());
        std::string history = "";
        std::mutex _history_mutex;
        auto duration = std::chrono::seconds(timelimit) - context.evolutionary.time_elapsed;
        std::atomic<bool> stop_flag(false);

        const int total_threads = context.shared_memory.num_threads;
        const int num_evo_workers = std::max(1, total_threads / 2);
        const int num_multilevel_threads = std::max(1, total_threads / num_evo_workers);
        std::atomic<int> total_mutations(0);
        std::atomic<int> total_combinations(0);
        std::atomic<int> total_iterations(0);

        timer.start_timer("evolutionary", "Evolutionary");

        LOG << "Starting evolutionary search with" << num_evo_workers << "workers, each using"
            << num_multilevel_threads << "threads for multilevel partitioning.";


        // task arenas for each worker to ensure isolated thread pools
        std::vector<std::unique_ptr<tbb::task_arena>> worker_arenas;
        for (int i = 0; i < num_evo_workers; i++) {
            worker_arenas.push_back(std::make_unique<tbb::task_arena>(num_multilevel_threads));
        }

        tbb::parallel_for(0, num_evo_workers, [&](int worker_id) {
            // Each evo worker uses own arena
            worker_arenas[worker_id]->execute([&] {
                while (!stop_flag) {
                    auto now = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch());
                    if (now - time_start >= duration) {
                        stop_flag = true;
                        break;
                    }
                    // Create a context for the inner run and set its thread limit
                    Context evo_context(context);
                    evo_context.type = ContextType::main;
                    evo_context.utility_id = utils::Utilities::instance().registerNewUtilityObjects();
                    evo_context.shared_memory.num_threads = num_multilevel_threads;

                    EvoDecision decision = decideNextMove(context);
                    EvoPartitioner<TypeTraits>::Hypergraph hg_copy = hg.copy(parallel_tag_t{});

                    // Ensure sanityCheck preconditions hold for any standard partitioning
                    // calls executed within workers by keeping part weights vector empty
                    // unless individual part weights are explicitly enabled by the user.
                    if (!evo_context.partition.use_individual_part_weights) {
                        evo_context.partition.max_part_weights.clear();
                    }
                    
                    switch (decision) {
                        case EvoDecision::mutation:
                            {
                                std::string h = performMutation(hg_copy, evo_context, target_graph, population);
                                if (!h.empty()) {
                                    std::lock_guard<std::mutex> lock(_history_mutex);
                                    history += h;
                                }
                                total_mutations++;
                                total_iterations++;
                                break;
                            }
                        case EvoDecision::combine:
                            {
                                std::string h = performCombine(hg_copy, evo_context, target_graph, population);
                                if (!h.empty()) {
                                    std::lock_guard<std::mutex> lock(_history_mutex);
                                    history += h;
                                }
                                total_combinations++;
                                total_iterations++;
                                break;
                            }
                        default:
                            LOG << "Error in evo_partitioner.cpp: Non-covered case in decision making";
                            std::exit(EXIT_FAILURE);
                    }
                }
            });
        });
        timer.stop_timer("evolutionary");

        context.evolutionary.iteration += total_iterations.load();
        context.partition.verbose_output = true;
        LOG << "Performed " << total_iterations.load() << " Evolutionary Iterations" << "\n";
        LOG << "    " << total_mutations.load() << " Mutations" << "\n";
        LOG << "    " << total_combinations.load() << " Combinations" << "\n";

        return history;
    }

    // Static member definitions for all TypeTraits (template required)
    template<typename TypeTraits>
    std::mutex EvoPartitioner<TypeTraits>::best_tracking_mutex_;

    template<typename TypeTraits>
    HyperedgeWeight EvoPartitioner<TypeTraits>::global_best_fitness_ = std::numeric_limits<HyperedgeWeight>::max();

    template<typename TypeTraits>
    std::chrono::milliseconds EvoPartitioner<TypeTraits>::global_best_time_{ 0 };

    template<typename TypeTraits>
    std::string EvoPartitioner<TypeTraits>::checkAndLogNewBest(
        HyperedgeWeight fitness,
        const std::string& operation_type,
        std::chrono::milliseconds current_time) {
    
        std::lock_guard<std::mutex> lock(best_tracking_mutex_);
        
        if (fitness < global_best_fitness_) {
            global_best_fitness_ = fitness;
            global_best_time_ = current_time;
                    
            return std::to_string(current_time.count()) + ", " + operation_type + ", " + 
                std::to_string(fitness) + "\n";
        }
    
    return "";

    
}

template<typename TypeTraits>
std::string EvoPartitioner<TypeTraits>::diff_matrix_history = "";

template<typename TypeTraits>
std::mutex EvoPartitioner<TypeTraits>::diff_matrix_history_mutex;

}  // namespace mt_kahypar