#include "evo_partitioner.h"
#include "mt-kahypar/partition/partitioner.h"
#include "mt-kahypar/partition/multilevel.h"
#include "mt-kahypar/partition/recursive_bipartitioning.h"
#include "mt-kahypar/partition/deep_multilevel.h"
#include "mt-kahypar/partition/preprocessing/sparsification/degree_zero_hn_remover.h"
#include "mt-kahypar/partition/preprocessing/sparsification/large_he_remover.h"
#include "mt-kahypar/io/partitioning_output.h"
#ifdef KAHYPAR_ENABLE_STEINER_TREE_METRIC
#include "mt-kahypar/partition/mapping/initial_mapping.h"
#endif

#include "mt-kahypar/io/hypergraph_io.h"
#include "mt-kahypar/io/presets.h"
#include "mt-kahypar/io/command_line_options.h"
#include "mt-kahypar/partition/evolutionary/evo_logs.h" 
#include <fstream>
#include <string>
#include <tbb/task_arena.h>
#include <csignal>

namespace mt_kahypar {


    template<typename TypeTraits>
    const Individual& EvoPartitioner<TypeTraits>::addThreadLocalTemporary(Individual&& individual) {
        thread_local_temporaries_.push_back(std::make_unique<Individual>(std::move(individual)));
        return *thread_local_temporaries_.back();
    }

    template<typename TypeTraits>
    void EvoPartitioner<TypeTraits>::clearThreadLocalTemporaries() {
        thread_local_temporaries_.clear();
    }

    template<typename TypeTraits>
    typename EvoPartitioner<TypeTraits>::PartitionedHypergraph EvoPartitioner<TypeTraits>::partition(
        Hypergraph& hypergraph, Context& context, TargetGraph* target_graph) {

        EvoPartitioner<TypeTraits>::configurePreprocessing(hypergraph, context);
        EvoPartitioner<TypeTraits>::setupContext(hypergraph, context, target_graph);

        io::printContext(context);
        io::printMemoryPoolConsumption(context);
        io::printInputInformation(context, hypergraph);

        #ifdef KAHYPAR_ENABLE_STEINER_TREE_METRIC
        bool map_partition_to_target_graph_at_the_end = false;
        if ( context.partition.objective == Objective::steiner_tree &&
            context.mapping.use_two_phase_approach ) {
        map_partition_to_target_graph_at_the_end = true;
        context.partition.objective = Objective::km1;
        context.setupGainPolicy();
        }
        #endif

        // init global timers for benchmark mode
        {
            std::lock_guard<std::mutex> lock(best_tracking_mutex_);
            global_best_fitness_ = std::numeric_limits<HyperedgeWeight>::max();
            global_best_time_ = std::chrono::milliseconds(0);
            improvement_log_entries.clear();
        }
        {
            std::lock_guard<std::mutex> lock(iteration_log_mutex);
            iteration_log_entries.clear();
        }

        // DISABLED -- Individuals have incorrect indexing after preprocessing
        // ################## PREPROCESSING ##################
        utils::Timer& timer = utils::Utilities::instance().getTimer(context.utility_id);
        timer.start_timer("preprocessing", "Preprocessing");
        // DegreeZeroHypernodeRemover<TypeTraits> degree_zero_hn_remover(context);
        // LargeHyperedgeRemover<TypeTraits> large_he_remover(context);
        // Partitioner<TypeTraits>::preprocess(hypergraph, context, target_graph);
        // EvoPartitioner<TypeTraits>::sanitize(hypergraph, context, degree_zero_hn_remover, large_he_remover);
        timer.stop_timer("preprocessing");

        // ################## EVOLUTIONARY PARTITIONING ##################
        //LOG << "DEBUG: Calling generateInitialPopulation...";
        // The initial population is generated by calling the standard partitioner repeatedly.
        Population population;
        std::string history = generateInitialPopulation(hypergraph, context, target_graph, population);
        //LOG << "DEBUG: generateInitialPopulation finished.";

        //LOG << "DEBUG: Calling performEvolution...";
        history += performEvolution(hypergraph, context, target_graph, population);
        //LOG << "DEBUG: performEvolution finished.";

        if (context.evolutionary.history_file != "" && context.partition.enable_benchmark_mode) {
            std::ofstream out_stream(context.evolutionary.history_file.c_str(), 
                                   std::ios::out | std::ios::trunc); 
            out_stream << history;
            for (const auto& entry : improvement_log_entries) {
                out_stream << entry.timestamp << ", " << entry.operation_type << ", " << entry.km1 << "\n";
            }
            out_stream.close();
        }
        if (context.evolutionary.diff_matrix_file != "" && context.partition.enable_benchmark_mode) {
            std::ofstream out_stream(context.evolutionary.diff_matrix_file.c_str(),
                                   std::ios::out | std::ios::trunc);
            out_stream << diff_matrix_history;
            out_stream.close();
        }
        if (context.evolutionary.enable_iteration_logging & context.partition.enable_benchmark_mode) {
            std::ofstream out_stream(context.evolutionary.iteration_log_file.c_str(),
                                   std::ios::out | std::ios::trunc);


           size_t line_count = iteration_log_entries.size();
           size_t log_limit = context.evolutionary.iteration_log_limit;

           // print every 1/line_countth line if limit is exceeded + last line
            if (line_count > log_limit) {
                    size_t step = line_count / log_limit;
                    for (size_t i = 0; i < line_count; ++i) {
                        if (i % step == 0 || i == line_count - 1) {
                            const auto& entry = iteration_log_entries[i];
                            out_stream << entry.iteration << ", " << entry.timestamp << ", " << entry.km1 << "\n";
                        }
                    }
            } else {
                for (const auto& entry : iteration_log_entries) {
                    out_stream << entry.iteration << ", " << entry.timestamp << ", " << entry.km1 << "\n";
                }
            }
            out_stream.close();
        }


        // ################## FINALIZATION ##################
        // After evolution, we take the best individual and create the final partition.
        PartitionedHypergraph final_partition(context.partition.k, const_cast<Hypergraph&>(hypergraph));
        
        size_t best_idx = population.bestSafe();
        std::vector<PartitionID> best_partition_vec = population.individualAtSafe(best_idx).partition();
        final_partition.doParallelForAllNodes([&](const HypernodeID& hn) {
            final_partition.setOnlyNodePart(hn, best_partition_vec[hn]);
        });
        final_partition.initializePartition();

        ASSERT([&] {
            bool success = true;
            if ( final_partition.hasFixedVertices() ) {
                for ( const HypernodeID& hn : final_partition.nodes() ) {
                    if ( final_partition.isFixed(hn) &&
                        final_partition.fixedVertexBlock(hn) != final_partition.partID(hn) ) {
                        LOG << "Node" << hn << "is fixed to block" << final_partition.fixedVertexBlock(hn)
                            << ", but is assigned to block" << final_partition.partID(hn);
                        success = false;
                    }
                }
            }
            return success;
        }(), "Some fixed vertices are not assigned to their corresponding block");

        // ################## POSTPROCESSING ##################
        timer.start_timer("postprocessing", "Postprocessing");
        // large_he_remover.restoreLargeHyperedges(final_partition);
        // degree_zero_hn_remover.restoreDegreeZeroHypernodes(final_partition);
        // forceFixedVertexAssignment(partitioned_hypergraph, context);
        timer.stop_timer("postprocessing");

        #ifdef KAHYPAR_ENABLE_STEINER_TREE_METRIC
            if ( map_partition_to_target_graph_at_the_end ) {
            ASSERT(target_graph);
            context.partition.objective = Objective::steiner_tree;
            timer.start_timer("one_to_one_mapping", "One-To-One Mapping");
            InitialMapping<TypeTraits>::mapToTargetGraph(
                 final_partition, *target_graph, context);
            timer.stop_timer("one_to_one_mapping");
            }
        #endif

        if (context.partition.verbose_output) {
            io::printHypergraphInfo(final_partition.hypergraph(), context,
                                    "Uncoarsened Hypergraph", context.partition.show_memory_consumption);
            io::printStripe();
        }

        return final_partition;
    }


    template<typename TypeTraits>
    std::string EvoPartitioner<TypeTraits>::generateInitialPopulation(const Hypergraph& hg, Context& context, TargetGraph* target_graph, Population& population) {
        context.partition.verbose_output = false;
        utils::Timer& timer = utils::Utilities::instance().getTimer(context.utility_id);
        auto start = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch());
        auto now = start;
        auto time_elapsed = now - start;
        auto duration = std::chrono::seconds(context.partition.time_limit);
        std::string history = "Starttime: " + std::to_string(start.count()) + "\n";

        // META-EVO LOGIC
        if (context.evolutionary.meta_evo_mode) {
            LOG << "DEBUG: Starting Meta-Evo Initial Population Generation";
            
            int target_pop_size = context.evolutionary.population_size;
            int solutions_per_run = context.evolutionary.meta_evo_solutions_per_run; // Default 2
            int num_meta_runs = (target_pop_size + solutions_per_run - 1) / solutions_per_run;

            for (int run = 0; run < num_meta_runs; run++) {
                now = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch());
                if (context.partition.time_limit > 0 && (now - start) >= duration) {
                    LOG << "DEBUG: Meta-Evo aborted due to global time limit.";
                    break;
                }

                LOG << "DEBUG: Meta-Evo Run " << (run + 1) << "/" << num_meta_runs;

                // Setup Sub-Context
                Context sub_context(context);
                sub_context.evolutionary.meta_evo_mode = false; // Prevent recursion
                
                // Sub-runs use stopping criteria, NOT the global time limit
                sub_context.partition.time_limit = 0; 
                sub_context.evolutionary.improvement_rate_stopping.enabled = true;
                Population sub_population;
                
                // Adjust seed for sub-runs if in deterministic mode
                if (sub_context.partition.deterministic) {
                    sub_context.partition.seed += run + 1; // +1 to differ from main run
                }
                // Reset global state for this sub-run to ensure stopping criteria works correctly
                {
                    std::lock_guard<std::mutex> lock(best_tracking_mutex_);
                    global_best_fitness_ = std::numeric_limits<HyperedgeWeight>::max();
                    global_best_time_ = std::chrono::milliseconds(0);
                    improvement_log_entries.clear();
                }
                {
                    std::lock_guard<std::mutex> lock(iteration_log_mutex);
                    iteration_log_entries.clear();
                }
                generateInitialPopulation(hg, sub_context, target_graph, sub_population);
                performEvolution(hg, sub_context, target_graph, sub_population);

                LOG << "DEBUG: Finished generating sub population";

                // Extract Best Individuals
                std::vector<std::pair<HyperedgeWeight, size_t>> fitness_indices;
                for (size_t i = 0; i < sub_population.size(); i++) {
                    LOG << "DEBUG: iterating";
                    fitness_indices.push_back({sub_population.fitnessAtSafe(i), i});
                }
                std::sort(fitness_indices.begin(), fitness_indices.end()); // Ascending (lower is better)

                int extracted = 0;
                for (const auto& pair : fitness_indices) {
                    if (extracted >= solutions_per_run) break;
                    if (population.size() >= static_cast<size_t>(target_pop_size)) break;

                    LOG << "DEBUG: Before copying";
                    size_t idx = pair.second;
                    // Copy individual from sub_population to main population
                    Individual ind_copy = sub_population.individualAtSafe(idx).copy(); 
                    LOG << "DEBUG: Before inserting";
                    // Add starting individuals to "real" population
                    population.addStartingIndividual(ind_copy, context);
                    extracted++;
                }
            }         
            context.partition.verbose_output = true;
            return history;
        }

        // if deterministic, save original seed to reset after initial population generation
        const int original_seed = context.partition.seed;
        if (context.partition.deterministic && context.partition.enable_benchmark_mode) {
            context.partition.seed = 0;
        }
               
        // INITIAL POPULATION
        if (context.evolutionary.dynamic_population_size) {
            HighResClockTimepoint start = std::chrono::high_resolution_clock::now();
            timer.start_timer("evolutionary", "Evolutionary");
            auto fitness = generateIndividual(hg, context, target_graph, population).fitness();
            now = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch());

            // best result tracking for benchmark
            if (context.partition.enable_benchmark_mode) {
                checkAndLogNewBest(fitness, "Initial", now, context.evolutionary.iteration);
            }

            timer.stop_timer("evolutionary");

            ++context.evolutionary.iteration;
            int dynamic_population_size = std::round(context.evolutionary.dynamic_population_amount_of_time
                                                    * context.partition.time_limit
                                                    / timer.get("evolutionary"));
            int minimal_size = std::max(dynamic_population_size, 3);

            context.evolutionary.population_size = std::min(minimal_size, 50);
            // limit kway combine to population size
            context.evolutionary.kway_combine = std::min(context.evolutionary.kway_combine,
                                                        int(context.evolutionary.population_size));

            LOG << context.evolutionary.population_size;
            //LOG << population;

            // increment seed if deterministic
            if (context.partition.deterministic) {
                context.partition.seed++;
            }
        }
        LOG << "DEBUG: Initial population target size =" << context.evolutionary.population_size;
        int best = std::numeric_limits<HyperedgeWeight>::max();
        int iteration = 0;

        while (population.size() < context.evolutionary.population_size &&
            time_elapsed <= duration) {
            //LOG << "DEBUG: Initial pop loop - Iteration" << iteration << ", Pop size:" << population.size();
            ++context.evolutionary.iteration;
            timer.start_timer("evolutionary", "Evolutionary");
           
            auto cur = generateIndividual(hg, context, target_graph, population).fitness();
            timer.stop_timer("evolutionary");
            now = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch());
            
            if (context.partition.enable_benchmark_mode) {
                checkAndLogNewBest(cur, "Initial", now, context.evolutionary.iteration);
            }
            
            // if (iteration == 0 || (cur < best)) {
            //     best = cur;
            //     history += "" + std::to_string(now.count()) + ", Repetition, " + std::to_string(cur) + "\n";
            // }
            iteration++;
            time_elapsed = now - start;

            // increment seed if in benchmark mode
            
            if (context.partition.deterministic) {
                context.partition.seed++;
            }
        }

        // reset seed after initial population generation
        if (context.partition.deterministic && context.partition.enable_benchmark_mode) {
            context.partition.seed = original_seed;
        }

        context.evolutionary.time_elapsed = time_elapsed;
        context.partition.verbose_output = true;
        return history;
    }

    template<typename TypeTraits>
    const Individual & EvoPartitioner<TypeTraits>::generateIndividual(const Hypergraph& input_hg, Context& context, TargetGraph* target_graph, Population& population, bool insert_into_population) {
        Hypergraph hypergraph_copy = input_hg.copy(parallel_tag_t{});

        //LOG << "DEBUG: generateIndividual: Calling standard partitioner...";

        Context ip_context(context);

        // If we are not using individual part weights, ensure max_part_weights is empty
        if (!ip_context.partition.use_individual_part_weights) {
                ip_context.partition.max_part_weights.clear();
        }

        // PREPROCESSING
        DegreeZeroHypernodeRemover<TypeTraits> degree_zero_hn_remover(context);
        LargeHyperedgeRemover<TypeTraits> large_he_remover(context);
        Partitioner<TypeTraits>::preprocess(hypergraph_copy, context, target_graph);
        EvoPartitioner<TypeTraits>::sanitize(hypergraph_copy, context, degree_zero_hn_remover, large_he_remover);

        EvoPartitioner<TypeTraits>::PartitionedHypergraph partitioned_hypergraph;
        // PartitionedHypergraph partitioned_hypergraph =
        //     Partitioner<TypeTraits>::partition(hypergraph_copy, ip_context, target_graph);
        if (context.partition.mode == Mode::direct) {
            partitioned_hypergraph = Multilevel<TypeTraits>::partition(hypergraph_copy, context, target_graph);
        } else if (context.partition.mode == Mode::recursive_bipartitioning) {
            partitioned_hypergraph = RecursiveBipartitioning<TypeTraits>::partition(hypergraph_copy, context, target_graph);
        } else if (context.partition.mode == Mode::deep_multilevel) {
            partitioned_hypergraph = DeepMultilevel<TypeTraits>::partition(hypergraph_copy, context);
        } else {
            throw InvalidParameterException("Invalid partitioning mode!");
        }
        //LOG << "DEBUG: generateIndividual: Partitioner finished.";

        // POSTPROCESSING
        large_he_remover.restoreLargeHyperedges(partitioned_hypergraph);
        degree_zero_hn_remover.restoreDegreeZeroHypernodes(partitioned_hypergraph);
        //Partitioner<TypeTraits>::forceFixedVertexAssignment(partitioned_hypergraph, context);

        Individual individual(partitioned_hypergraph, context);
        if (!insert_into_population) {
            return EvoPartitioner<TypeTraits>::addThreadLocalTemporary(std::move(individual));
        }
        return population.addStartingIndividual(individual, context);
    } 

    template<typename TypeTraits>
    EvoDecision EvoPartitioner<TypeTraits>::decideNextMove(const Context& context, std::mt19937* rng) {

        float rand_val;
        if (!context.partition.deterministic)
             rand_val = utils::Randomize::instance().getRandomFloat(0, 1, THREAD_ID);
        else if (rng != nullptr) {
            std::uniform_real_distribution<float> dist(0.0f, 1.0f);
            rand_val = dist(*rng);
        }
        else {
            throw UnsupportedOperationException("Catastrophic Error! Deterministic mode requires passing rng!");
        }
  
        if (!context.evolutionary.enable_modified_combine) {
            if ( rand_val < context.evolutionary.mutation_chance ) {
                return EvoDecision::mutation;
            } 
            return EvoDecision::combine;
        }
        else {
            if ( rand_val < context.evolutionary.mutation_chance) {
                return EvoDecision::mutation;
            } 
            else if ( rand_val < context.evolutionary.mutation_chance + context.evolutionary.modified_combine_chance ) {
                return EvoDecision::modified_combine;
            }
            else {
                return EvoDecision::combine;
            }
        }
        
        return EvoDecision::combine;
    }

    template<typename TypeTraits>
    ContextModifierParameters EvoPartitioner<TypeTraits>::decideContextModificationParameters(const Context& context) {
        
        ContextModifierParameters params;

        // set to defaults
        params.k = context.partition.k;
        params.epsilon = context.partition.epsilon;

        // 5 options, equal probability (1/5 each)
        int choice = utils::Randomize::instance().getRandomInt(0, 4, THREAD_ID);
        switch (choice) {
            case 0:
                // modify epsilon (default = 3 * epsilon)
                params.epsilon = 3.0 * context.partition.epsilon;
                break;
            case 1: 
                // Random Partition
                params.use_random_partitions = true;
                break;
            case 2:
                // Degree Sorted Partition
                params.use_degree_sorted_partitions = true;
                break;
            case 3:
                // modify k (default = 2 * k)
                params.k = 2 * context.partition.k;
                break;
            case 4:
                // recursive bipartitioning
                params.recursive_bipartitioning = true;
                break;
            default:
                throw InvalidParameterException("Invalid choice for modified combine strategy");
        }

        return params;

    }

    template<typename TypeTraits>
    EvoMutateStrategy EvoPartitioner<TypeTraits>::decideNextMutation(const Context& context, std::mt19937* rng) {
        if (context.partition.deterministic) {
            if (rng == nullptr) {
                throw UnsupportedOperationException("Catastrophic Error! Deterministic mode requires passing rng!");
            }
            float rand_val;
            std::uniform_real_distribution<float> dist(0.0f, 1.0f);
            rand_val = dist(*rng);
            if ( rand_val < 0.5f ) {
                return EvoMutateStrategy::vcycle;
            }
            return EvoMutateStrategy::new_initial_partitioning_vcycle;
        }
        else {
            if (utils::Randomize::instance().flipCoin(THREAD_ID)) {
                return EvoMutateStrategy::vcycle;
            }
            return EvoMutateStrategy::new_initial_partitioning_vcycle;
        }
    }

    template<typename TypeTraits>
    std::vector<PartitionID> EvoPartitioner<TypeTraits>::createRandomPartition(const Hypergraph& hypergraph, const Context& context) {
        Hypergraph hg = hypergraph.copy(parallel_tag_t{});
        Context c(context);
        PartitionedHypergraph partitioned_hypergraph(context.partition.k, hg);

        const size_t base_seed = context.partition.seed;
        // Randomly assign nodes to blocks
        hg.doParallelForAllNodes([&](const HypernodeID& hn) {
            PartitionID block;
            if (context.partition.deterministic) {
                // derive a per-node seed deterministically
                size_t node_seed = base_seed + static_cast<size_t>(hn);
                std::mt19937 prng(static_cast<uint32_t>(node_seed));
                std::uniform_int_distribution<PartitionID> dist(0, context.partition.k - 1);
                block = dist(prng);
            } else {
                block = utils::Randomize::instance().getRandomInt(0, context.partition.k - 1, THREAD_ID);
            }
            partitioned_hypergraph.setOnlyNodePart(hn, block);
        });

        // Iinitialize partition data structures
        partitioned_hypergraph.initializePartition();

        // V-Cycle to improve partitioning
        Multilevel<TypeTraits>::partitionVCycle(hg, partitioned_hypergraph, c, nullptr);
        
        // extract partition
        std::vector<PartitionID> partition(hg.initialNumNodes(), 0);
        partitioned_hypergraph.doParallelForAllNodes([&](const HypernodeID& hn) {
            partition[hn] = partitioned_hypergraph.partID(hn);
        });
        return partition;
    }


    template<typename TypeTraits>
    std::vector<PartitionID> EvoPartitioner<TypeTraits>::createDegreeSortedPartition(const Hypergraph& hypergraph, const Context& context) {
        std::vector<std::pair<HypernodeID, size_t>> degrees;
        Hypergraph hg = hypergraph.copy(parallel_tag_t{});
        Context c(context);
        PartitionedHypergraph partitioned_hypergraph(context.partition.k, hg);

        for ( const HypernodeID& hn : hg.nodes() ) {
            degrees.emplace_back(hn, hg.nodeDegree(hn));
        }
        std::sort(degrees.begin(), degrees.end(),
                  [](const std::pair<HypernodeID, size_t>& a,
                     const std::pair<HypernodeID, size_t>& b) {
                        return a.second > b.second;
                  });

        std::vector<PartitionID> partition(hg.initialNumNodes(), 0);
        
        // Split partition based on degree -- equisize blocks
        size_t block_size = hg.initialNumNodes() / context.partition.k;
        for ( size_t i = 0; i < degrees.size(); ++i ) {
            PartitionID block = std::min(static_cast<PartitionID>(i / block_size), static_cast<PartitionID>(context.partition.k - 1));
            partitioned_hypergraph.setOnlyNodePart(degrees[i].first, block);
        }
        
        // Iinitialize partition data structures
        partitioned_hypergraph.initializePartition();

        // V-Cycle to improve partitioning
        Multilevel<TypeTraits>::partitionVCycle(hg, partitioned_hypergraph, c, nullptr);
        
        // extract partition
        partitioned_hypergraph.doParallelForAllNodes([&](const HypernodeID& hn) {
            partition[hn] = partitioned_hypergraph.partID(hn);
        });
        return partition;

    }

    template<typename TypeTraits>
    Context EvoPartitioner<TypeTraits>::modifyContext(const Context& context, ContextModifierParameters params) {
        Context modifiedContext(context);
        modifiedContext.partition.k = params.k;
        modifiedContext.partition.epsilon = params.epsilon;
        modifiedContext.partition.mode = params.recursive_bipartitioning ? Mode::recursive_bipartitioning : modifiedContext.partition.mode;
        return modifiedContext;
    }

    template<typename TypeTraits>
    vec<PartitionID> EvoPartitioner<TypeTraits>::combineModifiedPartitions(const Context& context, std::vector<std::vector<PartitionID>> parent_partitions) {
        vec<PartitionID> combined(parent_partitions[0].size());
        std::unordered_map<std::string, int> tuple_to_block;
        int current_community = 0;

        for (int vertex = 0; vertex < combined.size(); vertex++) {
            std::string partition_tuple;
            for (size_t i = 0; i < parent_partitions.size(); ++i) {
                partition_tuple += std::to_string(parent_partitions[i][vertex]) + ",";
            }

            if (tuple_to_block.find(partition_tuple) == tuple_to_block.end()) {
                tuple_to_block[partition_tuple] = current_community++;
            }

            combined[vertex] = tuple_to_block[partition_tuple];
        }

        return combined;
    }


    template<typename TypeTraits>
    Individual EvoPartitioner<TypeTraits>::performModifiedCombine(const Hypergraph& input_hg, const Context& context, ContextModifierParameters params, TargetGraph* target_graph, Population& population, std::mt19937* rng) {
        
        std::vector<std::vector<PartitionID>> parent_partitions;
        size_t best;

        if (context.partition.deterministic) {
            best = population.randomIndividualSafeDeterministic(context.partition.seed);
        }
        else {
            best = population.randomIndividualSafe();
        }
        
        // generate new parent individual with modified context
        Context modified_context = modifyContext(context, params);

        modified_context.setupPartWeights(input_hg.totalWeight());

        std::vector<PartitionID> modified_partition;
        
        ASSERT(params.use_random_partitions + params.use_degree_sorted_partitions <= 1,
               "Can only use one of random or degree-sorted partitions");
        if (params.use_random_partitions) {
            modified_partition = createRandomPartition(input_hg, modified_context);
        } else if (params.use_degree_sorted_partitions) {
            modified_partition = createDegreeSortedPartition(input_hg, modified_context);
        } else {
            modified_partition = generateIndividual(input_hg, modified_context, target_graph, population, false).partition();
        }
        
        std::vector<PartitionID> best_partition = population.partitionCopySafe(best);
        parent_partitions.push_back(best_partition);
        parent_partitions.push_back(modified_partition);
        std::unordered_map<PartitionID, int> comm_to_block;

        vec<PartitionID> comms = combineModifiedPartitions(context, parent_partitions);

        // release the temporary individual(s)
        EvoPartitioner<TypeTraits>::clearThreadLocalTemporaries();

        Hypergraph hypergraph = input_hg.copy(parallel_tag_t{});
        PartitionedHypergraph partitioned_hypergraph(context.partition.k, hypergraph); 

        for ( const HypernodeID& hn : hypergraph.nodes() ) {
            partitioned_hypergraph.setOnlyNodePart(hn, best_partition[hn]);
            if ( comm_to_block.find(comms[hn]) == comm_to_block.end() ) {
                comm_to_block[comms[hn]] = best_partition[hn];
            }
        }

        partitioned_hypergraph.initializePartition();
        hypergraph.setCommunityIDs(std::move(comms));
        if (context.partition.mode == Mode::direct) {
            //V-cycle requires a context with initialized part weights
            Context vc_context(context);
            vc_context.setupPartWeights(hypergraph.totalWeight());
            Multilevel<TypeTraits>::evolutionPartitionVCycle(hypergraph, partitioned_hypergraph, vc_context, comm_to_block, target_graph);
        } else {
            throw InvalidParameterException("Invalid partitioning mode!");
        }

        Individual individual(partitioned_hypergraph, context);
        return individual;
    }


    template<typename TypeTraits>
    vec<PartitionID> EvoPartitioner<TypeTraits>::combinePartitions(const Context& context, Population& population, const std::vector<size_t>& ids) {
        // aquire lock --- possibly unnecessary
        std::vector<std::vector<PartitionID>> parent_partitions;
        for (auto id : ids) {
            parent_partitions.push_back(population.partitionCopySafe(id)); // FIXED
        }

        vec<PartitionID> combined(parent_partitions[0].size());
        std::unordered_map<std::string, int> tuple_to_block;
        int current_community = 0;

        for (int vertex = 0; vertex < combined.size(); vertex++) {
            std::string partition_tuple;
            for (size_t i = 0; i < parent_partitions.size(); ++i) {
                partition_tuple += std::to_string(parent_partitions[i][vertex]) + ",";
            }

            if (tuple_to_block.find(partition_tuple) == tuple_to_block.end()) {
                tuple_to_block[partition_tuple] = current_community++;
            }

            combined[vertex] = tuple_to_block[partition_tuple];
        }

        return combined;
    }

    template<typename TypeTraits>
    bool EvoPartitioner<TypeTraits>::insert_individual_into_population(Individual&& individual, const Context& context, Population& population, int iteration) {
        bool improved = false;
        if (context.partition.enable_benchmark_mode) {
            auto time = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch());
            improved = checkAndLogNewBest(individual.fitness(), "Insert", time, iteration);
        }
        population.insert(std::move(individual), context);
        if (context.partition.enable_benchmark_mode && improved) {
            std::lock_guard<std::mutex> lock(diff_matrix_history_mutex);
            std::string diff_matrix = population.updateDiffMatrix();
            diff_matrix_history += diff_matrix;
        }
        return improved;
    }

    template<typename TypeTraits>
    Individual EvoPartitioner<TypeTraits>::performCombine(
        const Hypergraph& input_hg,
        const Context& context,
        TargetGraph* target_graph,
        Population& population) {
    std::vector<size_t> parents;

    size_t best;
    if (context.partition.deterministic) {
        // use dedicated deterministic method
        best = population.randomIndividualSafeDeterministic(context.partition.seed);
        parents.push_back(best);
        for (int x = 1; x < context.evolutionary.kway_combine; x++) {
            size_t new_parent = population.randomIndividualSafeDeterministic(context.partition.seed + x);
            parents.push_back(new_parent);
            if (population.fitnessAtSafe(new_parent) <= population.fitnessAtSafe(best)) {
                best = new_parent;
            }
        }
    }
    else {
        best = population.randomIndividualSafe();
        parents.push_back(best);
        for (int x = 1; x < context.evolutionary.kway_combine; x++) {
            size_t new_parent = population.randomIndividualSafe();
            parents.push_back(new_parent);
            if (population.fitnessAtSafe(new_parent) <= population.fitnessAtSafe(best)) {
                best = new_parent;
            }
        }
    }

    std::vector<PartitionID> best_partition = population.partitionCopySafe(best);
    std::unordered_map<PartitionID, int> comm_to_block;
    vec<PartitionID> comms = combinePartitions(context, population, parents);

    Hypergraph hypergraph = input_hg.copy(parallel_tag_t{});
    PartitionedHypergraph partitioned_hypergraph(context.partition.k, hypergraph);

    for (const HypernodeID& hn : hypergraph.nodes()) {
        partitioned_hypergraph.setOnlyNodePart(hn, best_partition[hn]);
        if (comm_to_block.find(comms[hn]) == comm_to_block.end()) {
        comm_to_block[comms[hn]] = best_partition[hn];
        }
    }

    partitioned_hypergraph.initializePartition();
    hypergraph.setCommunityIDs(std::move(comms));

    if (context.partition.mode == Mode::direct) {
        Context vc_context(context);
        vc_context.setupPartWeights(hypergraph.totalWeight());
        Multilevel<TypeTraits>::evolutionPartitionVCycle(
            hypergraph, partitioned_hypergraph, vc_context, comm_to_block, target_graph);
    } else {
        throw InvalidParameterException("Invalid partitioning mode!");
    }

    return Individual(partitioned_hypergraph, context);
    }

    template<typename TypeTraits>
    Individual EvoPartitioner<TypeTraits>::performMutation(
        const Hypergraph& input_hg,
        const Context& context,
        TargetGraph* target_graph,
        Population& population,
        std::mt19937* rng) {
    Hypergraph hypergraph = input_hg.copy(parallel_tag_t{});

    size_t mutation_position;
    std::vector<PartitionID> cur;
    PartitionedHypergraph partitioned_hypergraph(context.partition.k, hypergraph);
    EvoMutateStrategy mutation;
    if (context.partition.deterministic) {
        mutation_position = population.randomIndividualSafeDeterministic(context.partition.seed);
        cur = population.individualAtSafe(mutation_position).partition();
        mutation = decideNextMutation(context, rng);
    }
    else {
        mutation_position = population.randomIndividualSafe();
        cur = population.individualAtSafe(mutation_position).partition();
        mutation = decideNextMutation(context);
    }


    if (mutation == EvoMutateStrategy::vcycle) {
        vec<PartitionID> comms(hypergraph.initialNumNodes());
        std::unordered_map<PartitionID, int> comm_to_block;
        for (const HypernodeID& hn : hypergraph.nodes()) {
            partitioned_hypergraph.setOnlyNodePart(hn, cur[hn]);
            comms[hn] = cur[hn];
        }
        for (PartitionID i = 0; i < context.partition.k; i++) {
            comm_to_block[i] = i;
        }
        partitioned_hypergraph.initializePartition();
        hypergraph.setCommunityIDs(std::move(comms));
        if (context.partition.mode == Mode::direct) {
            Context vc_context(context);
            vc_context.setupPartWeights(hypergraph.totalWeight());
            Multilevel<TypeTraits>::evolutionPartitionVCycle(
                hypergraph, partitioned_hypergraph, vc_context, comm_to_block, target_graph);
        } else {
            throw InvalidParameterException("Invalid partitioning mode!");
        }
    } else if (mutation == EvoMutateStrategy::new_initial_partitioning_vcycle) {
        vec<PartitionID> comms(hypergraph.initialNumNodes());
        for (const HypernodeID& hn : hypergraph.nodes()) {
            comms[hn] = cur[hn];
        }
        hypergraph.setCommunityIDs(std::move(comms));
        Context mut_context(context);
        if (!mut_context.partition.use_individual_part_weights) {
            mut_context.partition.max_part_weights.clear();
        }
        partitioned_hypergraph = Partitioner<TypeTraits>::partition(
            hypergraph, mut_context, target_graph);
    }

    return Individual(partitioned_hypergraph, context);
    }

    inline void disableTimerAndStatsEvo(const Context& context) {
        if ( context.type == ContextType::main && context.partition.mode == Mode::direct ) {
            utils::Utilities& utils = utils::Utilities::instance();
            parallel::MemoryPool::instance().deactivate_unused_memory_allocations();
            utils.getTimer(context.utility_id).disable();
            utils.getStats(context.utility_id).disable();
        }
    }

    inline void enableTimerAndStatsEvo(const Context& context) {
        if ( context.type == ContextType::main && context.partition.mode == Mode::direct ) {
            utils::Utilities& utils = utils::Utilities::instance();
            parallel::MemoryPool::instance().activate_unused_memory_allocations();
            utils.getTimer(context.utility_id).enable();
            utils.getStats(context.utility_id).enable();
        }
    }

    template<typename TypeTraits>
    std::string EvoPartitioner<TypeTraits>::performEvolution(const Hypergraph& hg, Context& context, TargetGraph* target_graph, Population& population) {
        context.partition.verbose_output = false;
        int timelimit = context.partition.time_limit;
        utils::Timer& timer = utils::Utilities::instance().getTimer(context.utility_id);
        auto time_start = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch());
        std::string history = "";
        const bool enforce_time_limit = timelimit > 0;
        auto duration = std::chrono::seconds(timelimit) - context.evolutionary.time_elapsed;
        std::atomic<bool> stop_flag(false);

        const int total_threads = context.shared_memory.num_threads;
        int num_evo_workers = 0;
        int num_multilevel_threads = 0;

        if (context.evolutionary.num_threads_per_worker > 0) {
            num_multilevel_threads = std::min(total_threads, static_cast<int>(context.evolutionary.num_threads_per_worker));
            num_evo_workers = std::max(1, total_threads / num_multilevel_threads);
        } else {
            // Default behavior
            num_evo_workers = std::max(1, total_threads / 2);
            num_multilevel_threads = std::max(1, total_threads / num_evo_workers);
        }
        
        std::atomic<int> total_mutations(0);
        std::atomic<int> total_combinations(0);
        std::atomic<int> total_modifiedCombinations(0);
        std::atomic<int> total_iterations(0);

        // State for stopping criterion
        double early_window_improvement_rate = -1.0;
        std::mutex stopping_criterion_mutex;

        // Calculate ContextModifierParameters once before any workers start
        ContextModifierParameters modified_combine_params;
        if (context.evolutionary.enable_modified_combine) {
            const double k_result = context.partition.k * context.evolutionary.modified_combine_k_multiplier;
            ASSERT(k_result >= 1.0, "k multiplier result must be >= 1: " << k_result);
            ASSERT(std::abs(k_result - std::round(k_result)) < 1e-10, 
                "k multiplier must result in whole number: " << k_result);
            
            const PartitionID absolute_k = static_cast<PartitionID>(std::round(k_result));
            const double absolute_epsilon = std::min(0.99, 
                context.partition.epsilon * context.evolutionary.modified_combine_epsilon_multiplier);
            
            modified_combine_params = ContextModifierParameters{
                .use_random_partitions = context.evolutionary.modified_combine_use_random_partitions,
                .use_degree_sorted_partitions = context.evolutionary.modified_combine_use_degree_sorted_partitions,
                .k = absolute_k,
                .epsilon = absolute_epsilon,
                .recursive_bipartitioning = context.evolutionary.modified_combine_recursive_bipartitioning
            };
        }

        timer.start_timer("evolutionary", "Evolutionary");

        LOG << "Starting evolutionary search with" << num_evo_workers << "workers, each using"
            << num_multilevel_threads << "threads for multilevel partitioning.";

        const bool iteration_logging_enabled = context.evolutionary.enable_iteration_logging & context.partition.enable_benchmark_mode;
        const size_t log_limit = std::max<size_t>(1, context.evolutionary.iteration_log_limit);


        const int global_seed = context.partition.seed;
        //standard mode non-deterministic
        if (!context.partition.deterministic) {
            // task arenas for each worker to ensure isolated thread pools
            std::vector<std::unique_ptr<tbb::task_arena>> worker_arenas;
            for (int i = 0; i < num_evo_workers; i++) {
                worker_arenas.push_back(std::make_unique<tbb::task_arena>(num_multilevel_threads));
            }

            tbb::parallel_for(0, num_evo_workers, [&](int worker_id) {
                // Each evo worker uses own arena
                worker_arenas[worker_id]->execute([&] {
                    while (!stop_flag) {
                        auto now = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch());
                        if (enforce_time_limit && (now - time_start >= duration)) {
                            stop_flag = true;
                            break;
                        }
                        if (context.evolutionary.improvement_rate_stopping.enabled) {
                            std::unique_lock<std::mutex> stop_lock(stopping_criterion_mutex, std::try_to_lock);
                            if (stop_lock.owns_lock()) {
                                std::lock_guard<std::mutex> iter_lock(iteration_log_mutex);
                                std::lock_guard<std::mutex> best_lock(best_tracking_mutex_);

                                int last_improv_iter = -1;
                                if (!improvement_log_entries.empty()) {
                                    last_improv_iter = improvement_log_entries.back().iteration;
                                }

                                bool should_stop = evolutionary::stopping::sliding_window_improvement_rate_stop(
                                    last_improv_iter,
                                    improvement_log_entries,
                                    iteration_log_entries,
                                    context.evolutionary.improvement_rate_stopping.early_window_improvs,
                                    context.evolutionary.improvement_rate_stopping.recent_window_improvs,
                                    context.evolutionary.improvement_rate_stopping.alpha,
                                    context.evolutionary.improvement_rate_stopping.max_iters_without_improv,
                                    early_window_improvement_rate
                                );

                                if (should_stop) {
                                    stop_flag = true;
                                    break;
                                }
                            }
                        }

                        // Create a context for the inner run and set its thread limit
                        Context evo_context(context);
                        evo_context.type = ContextType::main;
                        evo_context.utility_id = utils::Utilities::instance().registerNewUtilityObjects();
                        evo_context.shared_memory.num_threads = num_multilevel_threads;

                        EvoDecision decision = decideNextMove(context);
                        EvoPartitioner<TypeTraits>::Hypergraph hg_copy = hg.copy(parallel_tag_t{});

                        // Ensure sanityCheck preconditions hold for any standard partitioning
                        // calls executed within workers by keeping part weights vector empty
                        // unless individual part weights are explicitly enabled by the user.
                        if (!evo_context.partition.use_individual_part_weights) {
                            evo_context.partition.max_part_weights.clear();
                        }
                        
                        switch (decision) {
                            case EvoDecision::mutation:
                                {
                                    Individual ind = performMutation(hg_copy, evo_context, target_graph, population);
                                    insert_individual_into_population(std::move(ind), evo_context, population, total_iterations.load() + 1);
                                    total_mutations++;
                                    total_iterations++;
                                    break;
                                }
                            case EvoDecision::combine:
                                {
                                    Individual ind = performCombine(hg_copy, evo_context, target_graph, population);
                                    insert_individual_into_population(std::move(ind), evo_context, population, total_iterations.load() + 1);
                                    total_combinations++;
                                    total_iterations++;
                                    break;
                                }
                            case EvoDecision::modified_combine:
                                {
                                    // decide modified combine parameters if mixed strategy is enabled
                                    Individual ind = performModifiedCombine(hg_copy, evo_context, modified_combine_params, target_graph, population);
                                    insert_individual_into_population(std::move(ind), evo_context, population, total_iterations.load() + 1);
                                    total_modifiedCombinations++;
                                    total_iterations++;
                                    break;
                                }
                            default:
                                LOG << "Error in evo_partitioner.cpp: Non-covered case in decision making";
                                std::exit(EXIT_FAILURE);
                        }

                        // Log current best KM1 after each iteration if enabled (iteration, timestamp, km1)
                        if ( iteration_logging_enabled ) {
                            // get current best KM1 from population
                            size_t best_idx = population.bestSafe();
                            auto current_km1 = population.individualAtSafe(best_idx).fitness();
                            auto ts_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
                                            std::chrono::high_resolution_clock::now().time_since_epoch()
                                            ).count();
                            std::lock_guard<std::mutex> lg(iteration_log_mutex);
                            iteration_log_entries.push_back({total_iterations.load(), ts_ms, static_cast<double>(current_km1)});
                        }
                    }
                });
            });
        }
        else {
            //determinstic mode
            const int batch_size = 5;
            std::vector<std::unique_ptr<Individual>> batch_individuals (batch_size);
            std::atomic<size_t> last_batch_filled = 0;
            std::atomic<int> items_finished_in_current_batch = 0;

            std::vector<std::unique_ptr<tbb::task_arena>> worker_arenas;
            for (int i = 0; i < num_evo_workers; i++) {
                worker_arenas.push_back(std::make_unique<tbb::task_arena>(num_multilevel_threads));
            }

            tbb::parallel_for(0, num_evo_workers, [&](int worker_id) {
                // Each evo worker uses its own arena
                worker_arenas[worker_id]->execute([&] {

                    while (!stop_flag) {
                        auto now = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch());
                        if (enforce_time_limit && (now - time_start >= duration)) {
                            stop_flag = true;
                            break;
                        }

                        int iteration_id = -1;
                        int batch_id = -1;
                        int batch_pos = -1;
                        while (true) {
                            const int cur = total_iterations.load(std::memory_order_relaxed);
                            const int cur_batch = cur / batch_size;

                            while (static_cast<size_t>(cur_batch) > last_batch_filled.load(std::memory_order_acquire)) {
                                if (stop_flag.load(std::memory_order_acquire)) {
                                    break;
                                }
                                std::this_thread::yield();
                            }
                            if (stop_flag.load(std::memory_order_acquire)) {
                                break;
                            }

                            int expected = cur;
                            if (total_iterations.compare_exchange_weak(expected, cur + 1, std::memory_order_acq_rel, std::memory_order_relaxed)) {
                                iteration_id = cur;
                                batch_id = cur_batch;
                                batch_pos = cur % batch_size;
                                break;
                            }
                        }
                        if (stop_flag.load(std::memory_order_acquire)) {
                            break;
                        }

                        // Create a thread-local copy of the context
                        Context evo_context(context);
                        evo_context.type = ContextType::main;
                        evo_context.utility_id = utils::Utilities::instance().registerNewUtilityObjects();
                        evo_context.shared_memory.num_threads = num_multilevel_threads;


                        evo_context.partition.seed = global_seed + iteration_id;

                        // Initialize task-local RNG
                        std::mt19937 rng(evo_context.partition.seed);

                        EvoDecision decision = decideNextMove(evo_context, &rng);
                        Hypergraph hg_copy = hg.copy(parallel_tag_t{});
                        Individual child;

                        switch (decision) {
                            case EvoDecision::mutation: {
                                child = performMutation(hg_copy, evo_context, target_graph, population, &rng);
                                total_mutations.fetch_add(1, std::memory_order_relaxed);
                                break;
                            }
                            case EvoDecision::combine: {
                                child = performCombine(hg_copy, evo_context, target_graph, population);
                                total_combinations.fetch_add(1, std::memory_order_relaxed);
                                break;
                            }
                            case EvoDecision::modified_combine: {
                                child = performModifiedCombine(hg_copy, evo_context, modified_combine_params, target_graph, population, &rng);
                                total_modifiedCombinations.fetch_add(1, std::memory_order_relaxed);
                                break;
                            }
                            default:
                                LOG << "Error: Non-covered case in decision making";
                                std::exit(EXIT_FAILURE);
                        }

                        // Store individual in batch
                        batch_individuals[static_cast<size_t>(batch_pos)] = std::make_unique<Individual>(std::move(child));
                        
                        int finished_count = items_finished_in_current_batch.fetch_add(1, std::memory_order_acq_rel) + 1;

                        if (finished_count == batch_size) {
                            // Insert entire batch into population
                            for (size_t i = 0; i < batch_size; ++i) {
                                const int current_batch_start_id = batch_id * batch_size;
                                insert_individual_into_population(std::move(*batch_individuals[i]), evo_context, population, current_batch_start_id + static_cast<int>(i) + 1);

                                if (iteration_logging_enabled) {
                                // One "iteration" per inserted individual
                                size_t best_idx = population.bestSafe();
                                auto current_km1 = population.individualAtSafe(best_idx).fitness();
                                auto ts_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
                                                std::chrono::high_resolution_clock::now().time_since_epoch()
                                            ).count();
                                std::lock_guard<std::mutex> lg(iteration_log_mutex);
                                iteration_log_entries.push_back({current_batch_start_id + static_cast<int>(i) + 1, ts_ms, static_cast<double>(current_km1)});
                                }  
                            }

                            // Deterministic stopping criterion evaluation at batch boundaries
                            if (context.evolutionary.improvement_rate_stopping.enabled &&
                                !stop_flag.load(std::memory_order_acquire)) {
                                std::lock_guard<std::mutex> stop_lock(stopping_criterion_mutex);
                                std::lock_guard<std::mutex> iter_lock(iteration_log_mutex);
                                std::lock_guard<std::mutex> best_lock(best_tracking_mutex_);

                                int last_improv_iter = -1;
                                if (!improvement_log_entries.empty()) {
                                    last_improv_iter = improvement_log_entries.back().iteration;
                                }

                                const bool should_stop = evolutionary::stopping::sliding_window_improvement_rate_stop(
                                    last_improv_iter,
                                    improvement_log_entries,
                                    iteration_log_entries,
                                    context.evolutionary.improvement_rate_stopping.early_window_improvs,
                                    context.evolutionary.improvement_rate_stopping.recent_window_improvs,
                                    context.evolutionary.improvement_rate_stopping.alpha,
                                    context.evolutionary.improvement_rate_stopping.max_iters_without_improv,
                                    early_window_improvement_rate
                                );

                                if (should_stop) {
                                    stop_flag.store(true, std::memory_order_release);
                                }
                            }

                            // Mark batch as filled
                            items_finished_in_current_batch.store(0, std::memory_order_release);
                            last_batch_filled.fetch_add(1, std::memory_order_release);
                        } 

                    } 
                });
            });
        }



        timer.stop_timer("evolutionary");

        // Update final diff matrix
        {
            std::lock_guard<std::mutex> lock(diff_matrix_history_mutex);
            std::string diff_matrix = population.updateDiffMatrix();
            diff_matrix_history += diff_matrix;
        }

        context.evolutionary.iteration += total_iterations.load();
        context.partition.verbose_output = true;
        LOG << "Performed " << total_iterations.load() << " Evolutionary Iterations" << "\n";
        LOG << "    " << total_mutations.load() << " Mutations" << "\n";
        LOG << "    " << total_combinations.load() << " Combinations" << "\n";
        if (context.evolutionary.enable_modified_combine) {
            LOG << "    " << total_modifiedCombinations.load() << " Modified Combinations" << "\n";
        }

        return history;
    }

    // Static member definitions for all TypeTraits (template required)
    template<typename TypeTraits>
    std::mutex EvoPartitioner<TypeTraits>::best_tracking_mutex_;

    template<typename TypeTraits>
    HyperedgeWeight EvoPartitioner<TypeTraits>::global_best_fitness_ = std::numeric_limits<HyperedgeWeight>::max();

    template<typename TypeTraits>
    std::chrono::milliseconds EvoPartitioner<TypeTraits>::global_best_time_{ 0 };

    template<typename TypeTraits>
    bool EvoPartitioner<TypeTraits>::checkAndLogNewBest(
        HyperedgeWeight fitness,
        const std::string& operation_type,
        std::chrono::milliseconds current_time,
        int iteration) {
    
        std::lock_guard<std::mutex> lock(best_tracking_mutex_);
        
        if (fitness < global_best_fitness_) {
            global_best_fitness_ = fitness;
            global_best_time_ = current_time;
            
            improvement_log_entries.push_back({current_time.count(), iteration, static_cast<double>(fitness), operation_type});
            return true;
        }
    
        return false;
    }

template<typename TypeTraits>
std::string EvoPartitioner<TypeTraits>::diff_matrix_history = "";

template<typename TypeTraits>
std::mutex EvoPartitioner<TypeTraits>::diff_matrix_history_mutex;

template<typename TypeTraits>
std::vector<evolutionary::IterationLogEntry>
EvoPartitioner<TypeTraits>::iteration_log_entries;

template<typename TypeTraits>
std::mutex EvoPartitioner<TypeTraits>::iteration_log_mutex;

template<typename TypeTraits>
std::vector<evolutionary::ImprovementLogEntry>
EvoPartitioner<TypeTraits>::improvement_log_entries;
template<typename TypeTraits>
thread_local std::vector<std::unique_ptr<Individual>> EvoPartitioner<TypeTraits>::thread_local_temporaries_;


}  // namespace mt_kahypar